# GitHub Actions 워크플로우 이름
name: BOJ Study Automation (Gemini API)

# 워크플로우 실행 조건
on:
  pull_request:
    branches: [main]
  schedule:
    - cron: "0 0 * * *" # 매일 자정(UTC)에 실행

# 실행될 작업(Job) 목록
jobs:
  # PR 검증 및 자동 병합 작업
  test-and-merge:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest

    # 작업에 필요한 권한 설정
    permissions:
      contents: write # README.md 업데이트 및 커밋/푸시를 위해 필요
      pull-requests: write # PR에 테스트 결과 댓글을 작성하기 위해 필요

    steps:
      # 1. 코드 체크아웃
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.head.ref }}

      # 2. Python 환경 설정
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      # 3. Java 환경 설정
      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "11"

      # 4. Python 의존성 설치
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-genai pytz beautifulsoup4 requests

      # 5. Gemini API 환경 테스트
      - name: Test Gemini API environment
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "🤖 Gemini API 환경 테스트..."
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "❌ GEMINI_API_KEY가 설정되지 않았습니다."
            exit 1
          fi
          
          cat > test_gemini_api.py << 'EOF'
          import os
          import sys
          try:
              from google import genai
              from google.genai import types
              print("✅ google-genai 라이브러리 import 성공")
              
              client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])
              print("✅ Gemini API 클라이언트 생성 성공")

              response = client.models.generate_content(
                  model="gemini-1.5-flash",
                  contents="Hello, can you respond with just 'API_TEST_SUCCESS'?",
              )
              
              if hasattr(response, "text") and "API_TEST_SUCCESS" in response.text:
                  print("✅ Gemini API 테스트 완료")
                  sys.exit(0)
              else:
                  text = response.text if hasattr(response, "text") else "No text"
                  print(f"⚠️ API 응답 확인: {text}")
                  sys.exit(0)
          except Exception as e:
              print(f"❌ Gemini API 연결 실패: {e}")
              sys.exit(1)
          EOF
          python test_gemini_api.py

      # 6. PR에서 변경된 파일들 및 문제 정보 추출
      - name: Extract changed files and problem info
        id: extract-info
        run: python scripts/extract_pr_info.py
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 7. 파일 구조 및 유효성 확인
      - name: Check valid problems
        id: check-validity
        run: |
          if [ "${{ steps.extract-info.outputs.has_valid_problems }}" = "false" ] || [ "${{ steps.extract-info.outputs.total_problems_count }}" = "0" ]; then
            echo "skip_tests=true" >> $GITHUB_OUTPUT
            echo "⚠️ 분석할 수 있는 유효한 문제가 없습니다."
          else
            echo "skip_tests=false" >> $GITHUB_OUTPUT
            echo "✅ ${{ steps.extract-info.outputs.total_problems_count }}개의 유효한 문제를 발견했습니다."
          fi

      # 8. 다중 문제 테스트 실행
      - name: Run multi-problem tests
        if: steps.check-validity.outputs.skip_tests == 'false'
        id: run-tests
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: python scripts/multi_test_runner.py
        continue-on-error: true

      # 9. 테스트 결과 분석
      - name: Analyze test results
        if: steps.check-validity.outputs.skip_tests == 'false'
        id: analyze-results
        run: |
          if [ -f "test_results_summary.json" ]; then
            echo "📊 테스트 결과 분석 중..."
            python -c "
import json
import os
with open('test_results_summary.json', 'r', encoding='utf-8') as f:
    results = json.load(f)
overall_success = results.get('overall_success', False)
total_problems = results.get('total_problems', 0)
passed_problems = results.get('passed_problems', 0)
partial_passed = results.get('partial_passed_problems', 0)
failed_problems = results.get('failed_problems', 0)
with open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8') as f:
    f.write(f'overall_result={'PASS' if overall_success else 'FAIL'}\n')
    f.write(f'total_problems={total_problems}\n')
    f.write(f'passed_problems={passed_problems}\n')
    f.write(f'partial_passed_problems={partial_passed}\n')
    f.write(f'failed_problems={failed_problems}\n')
    f.write(f'success_rate={round((passed_problems + partial_passed) / max(total_problems, 1) * 100, 1)}\n')
print(f'전체 결과: {'성공' if overall_success else '실패'}')
"
          else
            echo "❌ 테스트 결과 파일을 찾을 수 없습니다."
            echo "overall_result=FAIL" >> $GITHUB_OUTPUT
          fi

      # 10. README.md 업데이트 (성공한 문제들만)
      - name: Update README for successful problems
        if: steps.analyze-results.outputs.overall_result == 'PASS'
        run: |
          if [ -f "test_results_summary.json" ]; then
            echo "📊 README 업데이트 중..."
            python -c "
import json
import subprocess
import sys
from datetime import datetime
try:
    with open('test_results_summary.json', 'r', encoding='utf-8') as f:
        results = json.load(f)
    successful_problems = [d for d in results.get('details', []) if d['result'] in ['PASS', 'PARTIAL_PASS']]
    if not successful_problems:
        print('✅ 업데이트할 성공한 문제가 없습니다.')
        sys.exit(0)
    print(f'✅ README 업데이트 대상: {len(successful_problems)}개 문제')
    for problem in successful_problems:
        cmd = [
            'python', 'scripts/update_readme.py',
            '--problem-id', str(problem['problem_id']),
            '--author', problem['author'],
            '--submission-date', datetime.now().strftime('%Y-%m-%d'),
            '--language', 'Java'
        ]
        try:
            subprocess.run(cmd, check=True, timeout=30)
            print(f'  - 문제 {problem['problem_id']} README 업데이트 완료')
        except Exception as e:
            print(f'  - ⚠️ 문제 {problem['problem_id']} README 업데이트 실패: {e}')
except Exception as e:
    print(f'❌ README 업데이트 중 오류: {e}')
    sys.exit(1)
"
          fi

      # 11. README.md 변경사항을 PR 브랜치에 커밋 및 푸시
      - name: Commit and Push README changes
        if: steps.analyze-results.outputs.overall_result == 'PASS'
        run: |
          git config --local user.email "${{ github.event.pull_request.user.login }}@users.noreply.github.com"
          git config --local user.name "${{ github.event.pull_request.user.login }}"
          git add README.md
          if ! git diff --cached --quiet; then
            SUCCESS_COUNT="${{ steps.analyze-results.outputs.passed_problems }}"
            PARTIAL_COUNT="${{ steps.analyze-results.outputs.partial_passed_problems }}"
            TOTAL_COUNT="${{ steps.analyze-results.outputs.total_problems }}"
            git commit -m "docs(readme): 푼 문제 업데이트 (${SUCCESS_COUNT}+${PARTIAL_COUNT}/${TOTAL_COUNT}) by ${{ steps.extract-info.outputs.author }}"
            git push origin ${{ github.event.pull_request.head.ref }}
          else
            echo "README.md에 변경사항이 없어 커밋하지 않습니다."
          fi

      # 12. 상세한 성공 알림 전송
      - name: Send detailed success notification
        if: steps.analyze-results.outputs.overall_result == 'PASS'
        env:
          MATTERMOST_WEBHOOK_URL: ${{ secrets.MATTERMOST_WEBHOOK_URL }}
        run: |
          echo "📢 성공 알림 전송 중..."
          python -c "
import json, subprocess, os, tempfile
try:
    with open('test_results_summary.json', 'r', encoding='utf-8') as f:
        results = json.load(f)
    
    total, passed, partial, failed = (
        results.get('total_problems', 0), results.get('passed_problems', 0),
        results.get('partial_passed_problems', 0), results.get('failed_problems', 0)
    )
    
    success_list = [f'**{d['problem_id']}** ({d['author']})' for d in results.get('details', []) if d['result'] == 'PASS']
    partial_list = [f'**{d['problem_id']}** ({d['author']})' for d in results.get('details', []) if d['result'] == 'PARTIAL_PASS']
    
    message_parts = [
        '🎉 **Multiple Problems Test Results**',
        f'**Total**: {total}개 | **Success**: {passed}개 | **Partial**: {partial}개 | **Failed**: {failed}개',
        f'**Success Rate**: {round((passed + partial) / max(total, 1) * 100, 1)}%',
        f'**PR**: ${{ github.event.pull_request.html_url }}'
    ]
    if success_list: message_parts.append(f'**✅ 완전 성공**: {' | '.join(success_list)}')
    if partial_list: message_parts.append(f'**⚠️ 부분 성공**: {' | '.join(partial_list)}')
    message_parts.append('🎯 한 문제 이상 성공으로 PR 승인됩니다!')
    
    payload = {'username': 'BOJ-Bot', 'icon_emoji': ':white_check_mark:', 'text': '\n\n'.join(message_parts)}
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json.dump(payload, f)
        payload_file = f.name
    
    webhook_url = os.environ.get('MATTERMOST_WEBHOOK_URL')
    if webhook_url:
        subprocess.run(['curl', '-X', 'POST', '-H', 'Content-Type: application/json', '-d', f'@{payload_file}', webhook_url, '--fail', '--silent', '--show-error'], check=True)
        os.unlink(payload_file)
        print('✅ 성공 알림 전송 완료')
    else:
        print('⚠️ MATTERMOST_WEBHOOK_URL이 설정되지 않아 알림을 건너뜁니다.')

except Exception as e:
    print(f'❌ 알림 전송 실패: {e}')
"

      # 13. 상세한 실패 알림 전송
      - name: Send detailed failure notification
        if: failure() && steps.check-validity.outputs.skip_tests == 'false'
        env:
          MATTERMOST_WEBHOOK_URL: ${{ secrets.MATTERMOST_WEBHOOK_URL }}
        run: |
          echo "📢 실패 알림 전송 중..."
          python -c "
import json, subprocess, os, tempfile
try:
    with open('test_results_summary.json', 'r', encoding='utf-8') as f:
        results = json.load(f)
    
    total, passed, partial, failed, error = (
        results.get('total_problems', 0), results.get('passed_problems', 0),
        results.get('partial_passed_problems', 0), results.get('failed_problems', 0),
        results.get('error_problems', 0)
    )
    
    failure_details = []
    for detail in results.get('details', []):
        if detail['result'] in ['FAIL', 'ERROR']:
            error_summary = (detail.get('errors', ['알 수 없는 오류'])[0] or '알 수 없는 오류')[:100]
            failure_details.append(f'**{detail['problem_id']}** ({detail['author']}): {error_summary}...')

    message_parts = [
        '❌ **Multiple Problems Test Failed**',
        f'**Total**: {total}개 | **Success**: {passed}개 | **Partial**: {partial}개 | **Failed**: {failed}개 | **Error**: {error}개',
        f'**PR**: ${{ github.event.pull_request.html_url }}'
    ]
    if failure_details:
        message_parts.append('**실패 상세:**')
        message_parts.extend(failure_details[:5])
        if len(failure_details) > 5: message_parts.append(f'... 외 {len(failure_details) - 5}개 더')
    message_parts.append('💪 코드를 수정한 후 다시 푸시해주세요!')
    
    payload = {'username': 'BOJ-Bot', 'icon_emoji': ':x:', 'text': '\n\n'.join(message_parts)}
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json.dump(payload, f)
        payload_file = f.name
    
    webhook_url = os.environ.get('MATTERMOST_WEBHOOK_URL')
    if webhook_url:
        subprocess.run(['curl', '-X', 'POST', '-H', 'Content-Type: application/json', '-d', f'@{payload_file}', webhook_url, '--fail', '--silent', '--show-error'], check=True)
        os.unlink(payload_file)
        print('✅ 실패 알림 전송 완료')
    else:
        print('⚠️ MATTERMOST_WEBHOOK_URL이 설정되지 않아 알림을 건너뜁니다.')

except Exception as e:
    print(f'❌ 알림 전송 실패: {e}')
"

      # 14. PR에 상세한 테스트 결과 댓글 작성
      - name: Comment detailed test results
        if: always() && steps.check-validity.outputs.skip_tests == 'false'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let results;
            try {
              if (fs.existsSync('test_results_summary.json')) {
                results = JSON.parse(fs.readFileSync('test_results_summary.json', 'utf8'));
              }
            } catch (error) {
              console.log('결과 파일 로드 실패:', error);
            }
            
            const overall_result = "${{ steps.analyze-results.outputs.overall_result }}";
            if (!results) {
              return github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `## ❌ 테스트 실행 실패\n\n테스트 결과 파일을 찾거나 분석할 수 없습니다. 워크플로우 로그를 확인해주세요.`
              });
            }
            
            const { passed_problems: passed = 0, partial_passed_problems: partial = 0, failed_problems: failed = 0, total_problems: total = 0 } = results;
            const successRate = Math.round((passed + partial) / Math.max(total, 1) * 1000) / 10;
            
            let body = `## 📊 다중 문제 테스트 결과\n\n**전체 결과**: ${overall_result === 'PASS' ? '✅ 성공' : '❌ 실패'} (성공률: ${successRate}%)\n\n| 구분 | 완전 성공 | 부분 성공 | 실패 | 전체 |\n|:---:|:---:|:---:|:---:|:---:|\n| 개수 | ${passed}개 | ${partial}개 | ${failed}개 | ${total}개 |\n\n`;
            
            if (results.details && results.details.length > 0) {
              body += `### 📝 문제별 상세 결과\n\n`;
              for (const detail of results.details) {
                const statusEmoji = { 'PASS': '✅', 'PARTIAL_PASS': '⚠️', 'FAIL': '❌', 'ERROR': '💥' }[detail.result] || '❓';
                body += `#### ${statusEmoji} 문제 ${detail.problem_id} (${detail.author})\n- **결과**: ${detail.result}\n`;
                if (detail.sample_tests) body += `- **샘플 테스트**: ${detail.sample_tests.passed}/${detail.sample_tests.total} 통과\n`;
                if (detail.generated_tests) body += `- **생성 테스트**: ${detail.generated_tests.passed}/${detail.generated_tests.total} 통과\n`;
                if (detail.errors && detail.errors.length > 0) body += `- **오류**: \`${detail.errors[0]}\`\n`;
                body += `\n`;
              }
            }
            
            if (overall_result === 'PASS') {
              body += `### 🎉 테스트 통과!\n\n한 문제 이상이 성공했으므로 **PR이 승인됩니다**. 실패한 문제들은 BOJ 사이트에서 직접 확인 후 수정해주세요.\n\n브랜치를 병합하고 삭제해주세요! 🚀`;
            } else {
              body += `### ❌ 테스트 실패\n\n모든 문제가 실패했습니다. 코드를 수정한 후 다시 푸시해주세요.\n\n💡 **팁**: 각 문제별 오류 메시지를 확인하여 수정해보세요.`;
            }
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      # 15. 테스트 결과 업로드 (디버그용)
      - name: Upload test results
        if: always() && steps.check-validity.outputs.skip_tests == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.event.pull_request.number }}
          path: |
            test_results_summary.json
            problems_info.json
            problem_*_info.json
            tests_*.json
            sample_*_tests.json
          retention-days: 7

  # 데드라인 알림 작업
  deadline-reminder:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests
      - name: Check deadlines and send reminders
        env:
          MATTERMOST_WEBHOOK_URL: ${{ secrets.MATTERMOST_WEBHOOK_URL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python scripts/deadline_checker.py
