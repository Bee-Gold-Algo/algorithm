# GitHub Actions 워크플로우 이름
name: BOJ Study Automation

# 워크플로우 실행 조건
on:
  pull_request:
    branches: [main]
  schedule:
    - cron: "* * * * *"

# 실행될 작업(Job) 목록
jobs:
  # PR 검증 및 자동 병합 작업
  test-and-merge:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest

    # 작업에 필요한 권한 설정
    permissions:
      contents: write # README.md 업데이트 및 커밋/푸시를 위해 필요
      pull-requests: write # PR에 테스트 결과 댓글을 작성하기 위해 필요

    steps:
      # 1. 코드 체크아웃
      # PR 브랜치 자체를 가져와 'Detached HEAD' 문제를 해결합니다.
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.head.ref }}

      # 2. Python 환경 설정
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      # 3. Java 환경 설정
      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: "temurin"
          java-version: "11"

      # 4. 시스템 의존성 설치 (Playwright용)
      - name: Install system dependencies for crawling
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libnss3 \
            libatk-bridge2.0-0 \
            libdrm2 \
            libxkbcommon0 \
            libgtk-3-0 \
            libgbm1 \
            libasound2 \
            libxrandr2 \
            libxcomposite1 \
            libxdamage1 \
            libxfixes3 \
            libatspi2.0-0 \
            libxss1 \
            libgconf-2-4

      # 5. Python 의존성 설치
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-generativeai pytz selenium webdriver-manager beautifulsoup4 requests playwright

      # 6. Playwright 브라우저 설치 및 설정
      - name: Install and setup Playwright
        run: |
          echo "🎭 Playwright 브라우저 설치 중..."
          python -m playwright install chromium
          python -m playwright install-deps
          echo "✅ Playwright 설치 완료"

      # 7. 네트워크 및 환경 테스트
      - name: Test crawling environment
        run: |
          echo "🌐 크롤링 환경 테스트..."
          echo "Python version: $(python --version)"
          echo "Playwright version: $(python -m playwright --version)"
          echo "Chromium path: $(python -c "import playwright; print(playwright.__file__)")"
          
          # 네트워크 연결 테스트
          echo "📡 네트워크 연결 테스트..."
          curl -I https://www.acmicpc.net/ --max-time 10 || echo "⚠️ 백준 직접 접근 제한됨"
          curl -I https://solved.ac/ --max-time 10 || echo "⚠️ solved.ac 접근 제한됨"
          
          # 간단한 Playwright 테스트
          echo "🎭 Playwright 기능 테스트..."
          python -c "
          from playwright.sync_api import sync_playwright
          with sync_playwright() as p:
              browser = p.chromium.launch(headless=True)
              page = browser.new_page()
              page.goto('https://httpbin.org/user-agent')
              print('User-Agent test:', page.text_content('body'))
              browser.close()
          " || echo "⚠️ Playwright 테스트 실패"


      # 8. PR에서 문제 및 코드 정보 추출 (GitHub API 사용으로 변경)
      - name: Extract problem and code info
        id: extract-info
        run: python scripts/extract_pr_info.py # 스크립트 내부에서 API를 호출하도록 변경
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # 9. 파일 구조 및 유효성 확인
      - name: Check valid problems
        id: check-validity
        run: |
          HAS_VALID_PROBLEMS="${{ steps.extract-info.outputs.has_valid_problems }}"
          PROBLEM_ID="${{ steps.extract-info.outputs.problem_id }}"

          if [ "$HAS_VALID_PROBLEMS" = "false" ] || [ "$PROBLEM_ID" = "0000" ]; then
            echo "skip_tests=true" >> $GITHUB_OUTPUT
            echo "⚠️ 분석할 수 있는 유효한 문제가 없습니다."
          else
            echo "skip_tests=false" >> $GITHUB_OUTPUT
            echo "✅ 유효한 문제를 발견했습니다. 크롤링을 시작합니다."
          fi

      # 10. 백준 문제 정보 크롤링 (강화된 재시도 로직)
      - name: Crawl BOJ problem information
        if: steps.check-validity.outputs.skip_tests == 'false'
        id: crawl-problem
        run: |
          PROBLEM_ID="${{ steps.extract-info.outputs.problem_id }}"
          echo "🎯 문제 $PROBLEM_ID 크롤링 시작..."
          
          # 여러 번 재시도
          SUCCESS=false
          for attempt in {1..3}; do
            echo "🚀 크롤링 시도 $attempt/3..."
            
            if python scripts/fetch_boj_problem.py --problem-id $PROBLEM_ID; then
              echo "✅ 크롤링 성공!"
              echo "crawl_success=true" >> $GITHUB_OUTPUT
              SUCCESS=true
              break
            else
              echo "❌ 크롤링 시도 $attempt 실패"
              if [ $attempt -lt 3 ]; then
                echo "⏳ 30초 후 재시도..."
                sleep 30
              fi
            fi
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "💥 모든 크롤링 시도 실패"
            echo "crawl_success=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      # 11. 크롤링 실패 시 대안 처리
      - name: Handle crawling failure
        if: steps.check-validity.outputs.skip_tests == 'false' && steps.crawl-problem.outputs.crawl_success != 'true'
        run: |
          PROBLEM_ID="${{ steps.extract-info.outputs.problem_id }}"
          echo "🛠️ 크롤링 실패로 인한 대안 처리..."
          
          # 기본적인 문제 정보 파일 생성
          cat > problem_info.json << EOF
          {
            "problem_id": "$PROBLEM_ID",
            "title": "문제 $PROBLEM_ID",
            "level": "N/A",
            "tags": [],
            "description": "크롤링 실패로 인해 문제 설명을 가져올 수 없습니다. https://www.acmicpc.net/problem/$PROBLEM_ID 에서 직접 확인해주세요.",
            "input_format": "입력 형식을 직접 확인해주세요.",
            "output_format": "출력 형식을 직접 확인해주세요.",
            "limits": "시간/메모리 제한을 직접 확인해주세요.",
            "hint": "",
            "samples": []
          }
          EOF
          
          # 빈 샘플 테스트 파일 생성
          cat > sample_tests.json << EOF
          {
            "problem_id": "$PROBLEM_ID",
            "test_cases": []
          }
          EOF
          
          echo "⚠️ 대안 정보 파일 생성 완료"

      # 12. 크롤링 결과 확인 및 검증
      - name: Verify crawled data
        if: steps.check-validity.outputs.skip_tests == 'false'
        run: |
          echo "📊 크롤링 결과 검증..."
          
          if [ -f problem_info.json ]; then
            echo "✅ problem_info.json 파일 존재"
            echo "📄 problem_info.json 내용:"
            cat problem_info.json | python -m json.tool | head -20
          else
            echo "❌ problem_info.json 파일 없음"
          fi
          
          if [ -f sample_tests.json ]; then
            echo "✅ sample_tests.json 파일 존재"
            echo "📄 sample_tests.json 내용:"
            cat sample_tests.json | python -m json.tool
          else
            echo "❌ sample_tests.json 파일 없음"
          fi

      # 13. Gemini API로 반례 테스트케이스 생성
      - name: Generate test cases with Gemini
        if: steps.check-validity.outputs.skip_tests == 'false'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "🤖 Gemini AI로 테스트케이스 생성 중..."
          python scripts/gemini_test_generator.py \
            --problem-id ${{ steps.extract-info.outputs.problem_id }} \
            --code-file ${{ steps.extract-info.outputs.code_file }} \
            --language ${{ steps.extract-info.outputs.language }} \
            --problem-info problem_info.json

      # 14. 모든 테스트 실행
      - name: Run all tests
        if: steps.check-validity.outputs.skip_tests == 'false'
        id: run-tests
        run: |
          echo "🧪 모든 테스트 실행 중..."
          python scripts/test_runner.py \
            --code-file ${{ steps.extract-info.outputs.code_file }} \
            --language ${{ steps.extract-info.outputs.language }} \
            --sample-tests sample_tests.json \
            --generated-tests generated_tests.json

      # 15. 테스트 통과 시 README.md 업데이트
      - name: Update README on success
        if: steps.run-tests.outputs.result == 'PASS'
        run: |
          echo "📝 README.md 업데이트 중..."
          python scripts/update_readme.py \
            --problem-id ${{ steps.extract-info.outputs.problem_id }} \
            --author ${{ steps.extract-info.outputs.author }} \
            --submission-date $(date '+%Y-%m-%d') \
            --language ${{ steps.extract-info.outputs.language }}

      # 16. README.md 변경사항을 PR 브랜치에 커밋 및 푸시
      - name: Commit and Push README changes
        if: steps.run-tests.outputs.result == 'PASS'
        run: |
          git config --local user.email "${{ github.event.pull_request.user.login }}@users.noreply.github.com"
          git config --local user.name "${{ github.event.pull_request.user.login }}"
          git add README.md
          if ! git diff --cached --quiet; then
            git commit -m "📊 Update progress: Problem ${{ steps.extract-info.outputs.problem_id }} solved by ${{ steps.extract-info.outputs.author }}"
            git push origin ${{ github.event.pull_request.head.ref }}
          else
            echo "README.md에 변경사항이 없어 커밋하지 않습니다."
          fi

      # 17. 크롤링 성공 시 Mattermost 알림
      - name: Send success notification with crawling info
        if: steps.run-tests.outputs.result == 'PASS'
        run: |
          PROBLEM_ID="${{ steps.extract-info.outputs.problem_id }}"
          AUTHOR="${{ steps.extract-info.outputs.author }}"
          LANGUAGE="${{ steps.extract-info.outputs.language }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_URL="${{ github.event.pull_request.html_url }}"
          CRAWL_SUCCESS="${{ steps.crawl-problem.outputs.crawl_success }}"
          
          # 크롤링 상태에 따른 메시지 조정
          if [ "$CRAWL_SUCCESS" = "true" ]; then
            CRAWL_STATUS="🕷️ 크롤링 성공"
          else
            CRAWL_STATUS="⚠️ 크롤링 실패 (대안 정보 사용)"
          fi

          cat > payload.json << EOF
          {
            "username": "BOJ-Bot",
            "icon_emoji": ":white_check_mark:",
            "text": "🎉 **Test Passed!**\\n\\n**Problem**: ${PROBLEM_ID}\\n**Solver**: ${AUTHOR}\\n**Language**: ${LANGUAGE}\\n**Status**: ${CRAWL_STATUS}\\n**PR**: ${PR_URL}\\n\\n✅ 모든 테스트를 통과했습니다!"
          }
          EOF

          curl -X POST \
            -H "Content-Type: application/json" \
            -d @payload.json \
            "${{ secrets.MATTERMOST_WEBHOOK_URL }}" \
            --fail --silent --show-error

      # 18. 테스트 실패 시 상세 알림
      - name: Send failure notification with details
        if: steps.run-tests.outputs.result == 'FAIL'
        run: |
          PROBLEM_ID="${{ steps.extract-info.outputs.problem_id }}"
          AUTHOR="${{ steps.extract-info.outputs.author }}"
          LANGUAGE="${{ steps.extract-info.outputs.language }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_URL="${{ github.event.pull_request.html_url }}"
          CRAWL_SUCCESS="${{ steps.crawl-problem.outputs.crawl_success }}"

          ERROR_DETAILS="${{ steps.run-tests.outputs.details }}"
          ERROR_DETAILS=$(echo "$ERROR_DETAILS" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/`/\\`/g')

          # 크롤링 상태 추가
          if [ "$CRAWL_SUCCESS" = "true" ]; then
            CRAWL_INFO="🕷️ 크롤링: 성공"
          else
            CRAWL_INFO="⚠️ 크롤링: 실패 (기본 정보로 테스트)"
          fi
          cat > payload.json << EOF
          {
            "username": "BOJ-Bot",
            "icon_emoji": ":x:",
            "text": "❌ **Test Failed!**\\n\\n**Problem**: ${PROBLEM_ID}\\n**Submitter**: ${AUTHOR}\\n**Language**: ${LANGUAGE}\\n**${CRAWL_INFO}**\\n**PR**: ${PR_URL}\\n\\n**Error Details:**\\n\`\`\`\\n${ERROR_DETAILS}\\n\`\`\`\\n\\n💪 코드를 수정한 후 다시 푸시해주세요!"
          }
          EOF

          curl -X POST \
            -H "Content-Type: application/json" \
            -d @payload.json \
            "${{ secrets.MATTERMOST_WEBHOOK_URL }}" \
            --fail --silent --show-error

      # 19. PR에 테스트 결과 댓글 작성 (크롤링 정보 포함)
      - name: Comment test results with crawling status
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { result, details } = ${{ toJSON(steps.run-tests.outputs) }};
            const { 
              author, 
              problem_id,
              has_valid_problems,
              problems_summary,
              total_problems_count,
              is_multiple_problems
            } = ${{ toJSON(steps.extract-info.outputs) }};
            
            const crawlSuccess = "${{ steps.crawl-problem.outputs.crawl_success }}";

            // 유효한 문제가 없는 경우  
            if (has_valid_problems === 'false' || problem_id === '0000') {
              const body = `## 📁 분석할 수 있는 문제가 없습니다

            **${author}**님의 PR에서 분석할 수 있는 Main.java 파일을 찾지 못했습니다.

            **확인 사항:**
            - 파일 경로가 \`본인이름/문제번호/Main.java\` 형식으로 작성되었는지 확인하세요
            - 실제로 변경사항이 있는 파일인지 확인하세요
            - PR에 본인의 파일만 포함되어 있는지 확인하세요

            ${problems_summary}

            올바른 형식으로 파일을 추가한 후 다시 푸시해주세요! 📝`;
                          
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
              return;
            }

            // 크롤링 상태 메시지 생성
            let crawlStatusEmoji = "";
            let crawlStatusText = "";
            
            if (crawlSuccess === 'true') {
              crawlStatusEmoji = "🕷️";
              crawlStatusText = "백준 사이트 크롤링 성공";
            } else {
              crawlStatusEmoji = "⚠️";
              crawlStatusText = "백준 사이트 크롤링 실패 (기본 정보로 테스트 진행)";
            }

            // 정상적인 테스트 결과 처리
            let body;
            
            // 여러 문제 변경 시 헤더 추가
            const multiProblemHeader = is_multiple_problems === 'true' ? 
              `## 📊 다중 문제 변경 감지 (총 ${total_problems_count}개)
              
            ${problems_summary}

            **현재 테스트**: 문제 ${problem_id} (우선순위 최상위)

            ---

            ` : '';

            if (result === 'PASS') {
              body = `${multiProblemHeader}## ✅ 테스트 통과!

            🎉 **${author}**님의 문제 **${problem_id}** 해결을 축하합니다!

            **테스트 결과:**
            - ✅ 샘플 테스트: 통과
            - 🤖 AI 생성 반례 테스트: 통과  
            - ${crawlStatusEmoji} 크롤링 상태: ${crawlStatusText}
            - 📊 README.md가 자동으로 업데이트되었습니다.

            ${is_multiple_problems === 'true' ? 
              `💡 **참고**: 이번 PR에서 변경된 다른 문제들도 동일하게 검증되었을 것으로 간주됩니다.` : 
              ''}

            브랜치 병합하고 삭제해주세요! 🚀`;

            } else {
              body = `${multiProblemHeader}## ❌ 테스트 실패

            **${author}**님의 문제 **${problem_id}** 코드에서 문제가 발견되었습니다:

            **테스트 상태:**
            - ${crawlStatusEmoji} 크롤링 상태: ${crawlStatusText}
            
            **오류 내용:**
            \`\`\`
            ${details}
            \`\`\`

            ${crawlSuccess !== 'true' ? 
              `⚠️ **크롤링 실패 안내**: 백준 사이트에서 문제 정보를 가져오지 못했습니다. 샘플 테스트케이스가 부족할 수 있으니 직접 확인 후 제출해주세요.` : 
              ''}

            ${is_multiple_problems === 'true' ? 
              `💡 **참고**: 우선순위가 가장 높은 문제부터 테스트합니다. 이 문제를 해결한 후 다시 푸시하면 다른 문제들도 함께 검증됩니다.` : 
              ''}

            코드를 수정한 후 다시 푸시해주세요! 💪`;
            }
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number, 
              owner: context.repo.owner, 
              repo: context.repo.repo, 
              body: body
            });

      # 20. 크롤링 디버그 정보 업로드
      - name: Upload crawling debug artifacts
        if: always() && steps.check-validity.outputs.skip_tests == 'false'
        uses: actions/upload-artifact@v3
        with:
          name: crawling-debug-${{ steps.extract-info.outputs.problem_id }}
          path: |
            *_screenshot.png
            *_page.html
            problem_info.json
            sample_tests.json
          retention-days: 7

      # 21. 다중 문제 알림 (Mattermost)
      - name: Send multiple problems notification
        if: steps.extract-info.outputs.multiple_problems == 'true'
        run: |
          PROBLEMS_COUNT="${{ steps.extract-info.outputs.problems_count }}"
          AUTHOR="${{ steps.extract-info.outputs.author }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_URL="${{ github.event.pull_request.html_url }}"

          cat > payload.json << EOF
          {
            "username": "BOJ-Bot",
            "icon_emoji": ":warning:",
            "text": "⚠️ **다중 문제 제출 감지**\\n\\n**${AUTHOR}**님이 PR #${PR_NUMBER}에서 ${PROBLEMS_COUNT}개의 문제를 동시에 제출했습니다.\\n\\n💡 **권장사항**: 문제별로 개별 PR을 만들어 주세요!\\n\\nPR 링크: ${PR_URL}"
          }
          EOF

          curl -X POST \
            -H "Content-Type: application/json" \
            -d @payload.json \
            "${{ secrets.MATTERMOST_WEBHOOK_URL }}" \
            --fail --silent --show-error

  # 데드라인 알림 작업
  deadline-reminder:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"
      - name: Check deadlines and send reminders
        env:
          MATTERMOST_WEBHOOK_URL: ${{ secrets.MATTERMOST_WEBHOOK_URL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python scripts/deadline_checker.py
